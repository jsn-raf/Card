<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Quick Notes</title>

  <link rel="manifest" href="/Notes/manifest.webmanifest">
  <meta name="theme-color" content="#f5f6f7">
  <meta name="mobile-web-app-capable" content="yes">

  <style>
    body{
      font-family:'Segoe UI', Roboto, sans-serif;
      margin:0;
      background:#fff;
      color:#202124;
      overflow:hidden;
    }

    .toolbar{
      background:#f5f6f7;
      padding:15px;
      display:flex;
      align-items:center;
      border-bottom:1px solid #e3e5e7;
      height:50px;
      position:relative;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
    }

    .back-arrow{
      font-size:20px;
      color:#5f6368;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      position:relative;
      z-index:3;
      padding:8px 10px;
      margin:-8px -10px;
      touch-action:manipulation;
    }

    .title{
      font-weight:500;
      margin-left:20px;
      -webkit-tap-highlight-color:transparent;
      pointer-events:none;
    }

    .calc-trigger{
      position:absolute;
      right:6px;
      top:50%;
      transform:translateY(-50%);
      width:44px;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }

    .dots{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:3px;
    }

    .vdot{
      width:4px;
      height:4px;
      border-radius:50%;
      background:#5f6368;
      opacity:0.65;
    }

    .calc-trigger.armed-top .vdot.top{
      background:#202124;
      opacity:1;
    }
    .calc-trigger.armed-bottom .vdot.bottom{
      background:#202124;
      opacity:1;
    }

    .peek-arrow{
      position:absolute;
      left:24px;
      top:50%;
      transform:translateY(-50%);
      display:none;
      pointer-events:none;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:12px;
      font-weight:700;
      line-height:1;
      letter-spacing:0.02em;
      color:#202124;
      text-align:center;
      z-index:2;
    }
    .peek-arrow .card{ display:block; margin-bottom:9px; }
    .peek-arrow .shift{ display:block; margin-top:9px; }

    .note-area{ padding:20px; }

    .note-body{
      font-size:18px;
      border:none;
      outline:none;
      width:100%;
      min-height:calc(100vh - 120px);
      resize:none;
      line-height:1.6;
      background:transparent;
      color:#202124;
      caret-color:#202124;
      -webkit-overflow-scrolling:touch;
    }
  </style>
</head>

<body>
  <div class="toolbar" id="toolbarBtn">
    <span class="back-arrow" id="resetBtn">←</span>

    <div class="peek-arrow" id="peekArrow">
      <span class="card" id="peekCard"></span>
      <span class="shift" id="peekShift"></span>
    </div>

    <span class="title">Quick Notes</span>

    <div class="calc-trigger" id="syncBtn" aria-hidden="true">
      <div class="dots">
        <span class="vdot top"></span>
        <span class="vdot mid"></span>
        <span class="vdot bottom"></span>
      </div>
    </div>
  </div>

  <div class="note-area">
    <textarea id="noteContent" class="note-body" placeholder="Tap to write..."></textarea>
  </div>

  <script>
    const stack = [
      "4C","2H","7D","3C","4H","6D","AS","5H","9S","2S","QH","3D",
      "QC","8H","6S","5S","9H","KC","2D","JH","3S","8S","6H","10C",
      "5D","KD","2C","3H","8D","5C","KS","JD","8C","10S","KH","JC",
      "7S","10H","AD","4S","7H","4D","AC","9C","JS","QD","7C","QS",
      "10D","6C","AH","9D"
    ];

    let lastOutCard = null;
    let lastOutShift = null;

    function clearArmed(){
      syncBtn.classList.remove("armed-top","armed-bottom");
    }
    function setArmed(which){
      clearArmed();
      syncBtn.classList.add(which === "bottom" ? "armed-bottom" : "armed-top");
    }

    function showPeekArrow(){
      if (!lastOutCard || lastOutShift == null) return;
      peekCard.textContent = lastOutCard;
      peekShift.textContent = lastOutShift;
      peekArrow.style.display = "block";
    }
    function hidePeekArrow(){
      peekArrow.style.display = "none";
      peekCard.textContent = "";
      peekShift.textContent = "";
    }

    // ---------- Parsing helpers (cards + numbers) ----------

    const suitMap = {
      "SPADES":"S","SPADE":"S","S":"S","♠":"S",
      "HEARTS":"H","HEART":"H","H":"H","♥":"H",
      "DIAMONDS":"D","DIAMOND":"D","D":"D","♦":"D",
      "CLUBS":"C","CLUB":"C","C":"C","♣":"C"
    };

    const rankMap = {
      "ACE":"A","A":"A",
      "KING":"K","K":"K",
      "QUEEN":"Q","Q":"Q",
      "JACK":"J","J":"J",
      "TEN":"10","10":"10",
      "NINE":"9","9":"9",
      "EIGHT":"8","8":"8",
      "SEVEN":"7","7":"7",
      "SIX":"6","6":"6",
      "FIVE":"5","5":"5",
      "FOUR":"4","4":"4",
      "THREE":"3","3":"3",
      "TWO":"2","2":"2",
      "ONE":"A" // note: for cards we *don't* treat "one" as rank; we'll ignore this below
    };

    function normaliseCard(input){
      if (!input) return null;
      const raw = String(input).trim().toUpperCase();

      // Compact formats: "AS", "10H", etc
      const compact = raw.replace(/\s+/g,"")
        .replaceAll("♠","S").replaceAll("♥","H").replaceAll("♦","D").replaceAll("♣","C");
      if (/^(10|[2-9AJQK])[CDHS]$/.test(compact)) return compact;

      // Tokenise words
      const cleaned = raw
        .replace(/[^A-Z0-9♠♥♦♣ ]/g," ")
        .replace(/\s+/g," ")
        .trim();

      const tokens = cleaned.split(" ").filter(t => t && t !== "OF" && t !== "THE" && t !== "A");

      // Find suit + rank in any order
      let suit = null;
      let rank = null;

      for (const t of tokens) {
        if (!suit && suitMap[t]) suit = suitMap[t];
      }

      for (const t of tokens) {
        // ranks for cards: allow ACE/K/Q/J + 2..10 + word ranks
        if (!rank) {
          if (t === "ONE") continue; // avoid mapping "one" to Ace for cards
          if (rankMap[t]) rank = rankMap[t];
          else if (/^(10|[2-9])$/.test(t)) rank = t;
        }
      }

      if (!rank || !suit) return null;
      const out = rank + suit;
      return (/^(10|[2-9AJQK])[CDHS]$/.test(out)) ? out : null;
    }

    // Position words 1..52
    const oneToNineteen = {
      "ONE":1,"TWO":2,"THREE":3,"FOUR":4,"FIVE":5,"SIX":6,"SEVEN":7,"EIGHT":8,"NINE":9,
      "TEN":10,"ELEVEN":11,"TWELVE":12,"THIRTEEN":13,"FOURTEEN":14,"FIFTEEN":15,"SIXTEEN":16,
      "SEVENTEEN":17,"EIGHTEEN":18,"NINETEEN":19
    };
    const tens = {
      "TWENTY":20,"THIRTY":30,"FORTY":40,"FIFTY":50
    };

    function wordsToNumber(s){
      const raw = String(s ?? "").toUpperCase().trim();
      if (!raw) return NaN;

      // Prefer digits anywhere
      const m = raw.match(/-?\d+/);
      if (m) return parseInt(m[0],10);

      // Normalise separators (spaces/hyphens)
      const tokens = raw
        .replace(/[^A-Z -]/g," ")
        .replace(/-/g," ")
        .replace(/\s+/g," ")
        .trim()
        .split(" ")
        .filter(Boolean);

      if (!tokens.length) return NaN;

      // Handle "FIFTY TWO" etc
      if (tokens.length === 1) {
        if (oneToNineteen[tokens[0]] != null) return oneToNineteen[tokens[0]];
        if (tens[tokens[0]] != null) return tens[tokens[0]];
      }

      if (tokens.length === 2) {
        const [a,b] = tokens;
        if (tens[a] != null && oneToNineteen[b] != null) return tens[a] + oneToNineteen[b];
        // Allow "TWENTY ONE" style only, not reversed
      }

      // Handle "FIFTY TWO" / "FORTY TWO" already covered; fallthrough
      return NaN;
    }

    function require1to52(n){
      return Number.isFinite(n) && n >= 1 && n <= 52 ? n : NaN;
    }

    function positionAfterCut(op, bp){
      const z = (op - bp - 1) % 52;
      return (z < 0 ? z + 52 : z) + 1;
    }

    // ---------- Compute ----------
    function compute(){
      const lines = noteContent.value.split("\n").map(l => l.trim()).filter(Boolean);
      if (lines.length < 2) return;

      const card = normaliseCard(lines[0]);
      const pos = require1to52(wordsToNumber(lines[1]));
      if (!card || isNaN(pos)) return;

      let usedThirdLine = false;
      let cur;

      if (lines[2]) {
        const bottom = normaliseCard(lines[2]);
        if (!bottom) return;
        usedThirdLine = true;
        cur = positionAfterCut(stack.indexOf(card)+1, stack.indexOf(bottom)+1);
        noteContent.value = lines.slice(0,2).join("\n") + "\n";
      } else {
        cur = stack.indexOf(card)+1;
      }

      const diff = cur - pos;
      if (diff === 0) {
        lastOutCard = "00";
        lastOutShift = "0";
      } else {
        let s = diff % 52;
        if (s < 0) s += 52;
        lastOutCard = stack[s-1];
        lastOutShift = String(s);
      }

      setArmed(usedThirdLine ? "bottom" : "top");
    }

    // ---------- Pointer-based gestures on toolbar ----------
    const toolbarBtn = document.getElementById("toolbarBtn");
    const resetBtn = document.getElementById("resetBtn");

    let holdTimer = null;
    let isHolding = false;
    let startX = 0, startY = 0;
    const HOLD_MS = 650;
    const MOVE_TOL = 10;

    function clearHold(){
      if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      isHolding = false;
    }

    function onToolbarPointerDown(e){
      if (e.pointerType === "mouse" && e.button !== 0) return;
      startX = e.clientX;
      startY = e.clientY;
      isHolding = false;

      clearHold();
      holdTimer = setTimeout(() => {
        isHolding = true;
        showPeekArrow();
      }, HOLD_MS);
    }

    function onToolbarPointerMove(e){
      if (!holdTimer) return;
      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      if (dx > MOVE_TOL || dy > MOVE_TOL) {
        clearHold();
        hidePeekArrow();
      }
    }

    function onToolbarPointerUpOrCancel(){
      const wasHolding = isHolding;
      clearHold();

      if (wasHolding) {
        hidePeekArrow();
        clearArmed();
        return;
      }

      hidePeekArrow();
      setTimeout(compute, 80);
    }

    // Arrow: stop propagation so it doesn't compute
    resetBtn.addEventListener("pointerdown", (e) => e.stopPropagation());
    resetBtn.addEventListener("pointerup", (e) => e.stopPropagation());
    resetBtn.addEventListener("click", (e) => e.stopPropagation());

    resetBtn.addEventListener("click", () => {
      clearHold();
      noteContent.value = "";
      lastOutCard = null;
      lastOutShift = null;
      clearArmed();
      hidePeekArrow();
    });

    toolbarBtn.addEventListener("pointerdown", onToolbarPointerDown);
    toolbarBtn.addEventListener("pointermove", onToolbarPointerMove);
    toolbarBtn.addEventListener("pointerup", onToolbarPointerUpOrCancel);
    toolbarBtn.addEventListener("pointercancel", onToolbarPointerUpOrCancel);

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/Notes/sw.js").catch(() => {});
    }
  </script>
</body>
</html>
